<!doctype html>

<meta charset="utf-8">

<title>Sims</title>

<link rel="stylesheet" type="text/css"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.5.0/codemirror.min.css">

<link rel="stylesheet" type="text/css" href="static/custom.css">

<h1 class='package-header'>Sims</h1>

<h1 id='module-reference'>Reference</h1>
<ul class='index'>
<li >
<strong>functions:</strong>
</li>
<li >
<ul >
<li >
<a href='#BoolEvent'>BoolEvent</a></li>
<li >
<a href='#Branch'>Branch</a></li>
<li >
<a href='#BranchHeatPort'>BranchHeatPort</a></li>
<li >
<a href='#Capacitor'>Capacitor</a></li>
<li >
<a href='#ControlledCloserWithArc'>ControlledCloserWithArc</a></li>
<li >
<a href='#ControlledIdealClosingSwitch'>ControlledIdealClosingSwitch</a></li>
<li >
<a href='#ControlledIdealOpeningSwitch'>ControlledIdealOpeningSwitch</a></li>
<li >
<a href='#ControlledOpenerWithArc'>ControlledOpenerWithArc</a></li>
<li >
<a href='#Diode'>Diode</a></li>
<li >
<a href='#EMF'>EMF</a></li>
<li >
<a href='#HeatingDiode'>HeatingDiode</a></li>
<li >
<a href='#IdealClosingSwitch'>IdealClosingSwitch</a></li>
<li >
<a href='#IdealDiode'>IdealDiode</a></li>
<li >
<a href='#IdealGTOThyristor'>IdealGTOThyristor</a></li>
<li >
<a href='#IdealOpAmp'>IdealOpAmp</a></li>
<li >
<a href='#IdealOpeningSwitch'>IdealOpeningSwitch</a></li>
<li >
<a href='#IdealThyristor'>IdealThyristor</a></li>
<li >
<a href='#Inductor'>Inductor</a></li>
<li >
<a href='#Resistor'>Resistor</a></li>
<li >
<a href='#SaturatingInductor'>SaturatingInductor</a></li>
<li >
<a href='#SeriesProbe'>SeriesProbe</a></li>
<li >
<a href='#SignalCurrent'>SignalCurrent</a></li>
<li >
<a href='#SignalVoltage'>SignalVoltage</a></li>
<li >
<a href='#SineVoltage'>SineVoltage</a></li>
<li >
<a href='#StepVoltage'>StepVoltage</a></li>
<li >
<a href='#Transformer'>Transformer</a></li>
<li >
<a href='#ZDiode'>ZDiode</a></li>
<li >
<a href='#addhook!'>addhook!</a></li>
<li >
<a href='#check'>check</a></li>
<li >
<a href='#compatible_values'>compatible_values</a></li>
<li >
<a href='#create_sim'>create_sim</a></li>
<li >
<a href='#create_simstate'>create_simstate</a></li>
<li >
<a href='#delay'>delay</a></li>
<li >
<a href='#der'>der</a></li>
<li >
<a href='#elaborate'>elaborate</a></li>
<li >
<a href='#ifelse'>ifelse</a></li>
<li >
<a href='#is_unknown'>is_unknown</a></li>
<li >
<a href='#mexpr'>mexpr</a></li>
<li >
<a href='#name'>name</a></li>
<li >
<a href='#pre'>pre</a></li>
<li >
<a href='#reinit'>reinit</a></li>
<li >
<a href='#value'>value</a></li>
</ul>
</li>
<li >
<strong>types:</strong>
</li>
<li >
<ul >
<li >
<a href='#DefaultUnknown'>DefaultUnknown</a></li>
<li >
<a href='#DerUnknown'>DerUnknown</a></li>
<li >
<a href='#Discrete'>Discrete</a></li>
<li >
<a href='#DiscreteVar'>DiscreteVar</a></li>
<li >
<a href='#EquationSet'>EquationSet</a></li>
<li >
<a href='#Event'>Event</a></li>
<li >
<a href='#InitialEquation'>InitialEquation</a></li>
<li >
<a href='#LeftVar'>LeftVar</a></li>
<li >
<a href='#MExpr'>MExpr</a></li>
<li >
<a href='#ModelType'>ModelType</a></li>
<li >
<a href='#Parameter{T<:UnknownCategory}'>Parameter{T<:UnknownCategory}</a></li>
<li >
<a href='#PassedUnknown'>PassedUnknown</a></li>
<li >
<a href='#RefBranch'>RefBranch</a></li>
<li >
<a href='#RefDiscrete'>RefDiscrete</a></li>
<li >
<a href='#RefUnknown{T<:UnknownCategory}'>RefUnknown{T<:UnknownCategory}</a></li>
<li >
<a href='#Sim'>Sim</a></li>
<li >
<a href='#SimFunctions'>SimFunctions</a></li>
<li >
<a href='#SimResult'>SimResult</a></li>
<li >
<a href='#SimState'>SimState</a></li>
<li >
<a href='#StructuralEvent'>StructuralEvent</a></li>
<li >
<a href='#UAngle'>UAngle</a></li>
<li >
<a href='#UAngularAcceleration'>UAngularAcceleration</a></li>
<li >
<a href='#UAngularVelocity'>UAngularVelocity</a></li>
<li >
<a href='#UCurrent'>UCurrent</a></li>
<li >
<a href='#UHeatFlow'>UHeatFlow</a></li>
<li >
<a href='#UHeatPort'>UHeatPort</a></li>
<li >
<a href='#UTemperature'>UTemperature</a></li>
<li >
<a href='#UTorque'>UTorque</a></li>
<li >
<a href='#UVoltage'>UVoltage</a></li>
<li >
<a href='#Union(AbstractArray{T,N},RefUnknown{DefaultUnknown},Unknown{DefaultUnknown},Number,MExpr)'>Union(AbstractArray{T,N},RefUnknown{DefaultUnknown},Unknown{DefaultUnknown},Number,MExpr)</a></li>
<li >
<a href='#Union(AbstractArray{T,N},Unknown{UVoltage},RefUnknown{UVoltage},Number,MExpr)'>Union(AbstractArray{T,N},Unknown{UVoltage},RefUnknown{UVoltage},Number,MExpr)</a></li>
<li >
<a href='#Union(RefUnknown{T},Unknown{T},AbstractArray{T,N},Number,MExpr)'>Union(RefUnknown{T},Unknown{T},AbstractArray{T,N},Number,MExpr)</a></li>
<li >
<a href='#Union(RefUnknown{UHeatPort},AbstractArray{T,N},Unknown{UHeatPort},Number,MExpr)'>Union(RefUnknown{UHeatPort},AbstractArray{T,N},Unknown{UHeatPort},Number,MExpr)</a></li>
<li >
<a href='#Union(Unknown{UAngle},AbstractArray{T,N},Number,MExpr,RefUnknown{UAngle})'>Union(Unknown{UAngle},AbstractArray{T,N},Number,MExpr,RefUnknown{UAngle})</a></li>
<li >
<a href='#UnknownCategory'>UnknownCategory</a></li>
<li >
<a href='#UnknownVariable'>UnknownVariable</a></li>
<li >
<a href='#Unknown{T<:UnknownCategory}'>Unknown{T<:UnknownCategory}</a></li>
<li >
<a href='#Unknown{UAngle}'>Unknown{UAngle}</a></li>
<li >
<a href='#Unknown{UAngularAcceleration}'>Unknown{UAngularAcceleration}</a></li>
<li >
<a href='#Unknown{UAngularVelocity}'>Unknown{UAngularVelocity}</a></li>
<li >
<a href='#Unknown{UCurrent}'>Unknown{UCurrent}</a></li>
<li >
<a href='#Unknown{UHeatFlow}'>Unknown{UHeatFlow}</a></li>
<li >
<a href='#Unknown{UHeatPort}'>Unknown{UHeatPort}</a></li>
<li >
<a href='#Unknown{UTorque}'>Unknown{UTorque}</a></li>
<li >
<a href='#Unknown{UVoltage}'>Unknown{UVoltage}</a></li>
</ul>
</li>
<li >
<strong>macros:</strong>
</li>
<li >
<ul >
<li >
<a href='#@equations'>@equations</a></li>
<li >
<a href='#@unknown'>@unknown</a></li>
</ul>
</li>
<li >
<strong>globals:</strong>
</li>
<li >
<ul >
<li >
<a href='#Equation'>Equation</a></li>
<li >
<a href='#MTime'>MTime</a></li>
<li >
<a href='#Model'>Model</a></li>
<li >
<a href='#StandardElectricalLibrary'>StandardElectricalLibrary</a></li>
<li >
<a href='#sim'>sim</a></li>
</ul>
</li>
</ul>
<div class='entries'>
<div class='entry'>
<div id='BoolEvent' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> BoolEvent
</div>
<div class='entry-body'>
<p>BoolEvent is a helper for attaching an event to a boolean variable. In conjunction with <code>ifelse</code>, this allows constructs like Modelica's if blocks.</p>
<p>Note that the lengths of <code>d</code> and <code>condition</code> must match for arrays.</p>
<pre><code>BoolEvent(d::Discrete, condition::ModelType)</code></pre>
<h1>Arguments</h1>
<ul><li>`d::Discrete` : the discrete variable.</li><li>`condition::ModelType` : the model expression(s) </li></ul>
<h1>Returns</h1>
<ul><li>`::Event` : a model Event</li></ul>
<h1>Examples</h1>
<p>See IdealDiode and Limiter in the standard library.</p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L1159'>Sims/src/main.jl:1159</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Branch' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> Branch
</div>
<div class='entry-body'>
<p>A helper Model to connect a branch between two different nodes and specify potential between nodes and the flow between nodes.</p>
<p>See also <code>RefBranch</code>.</p>
<pre><code>Branch(n1, n2, v, i)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1` : the positive reference node.</li><li>`n2` : the negative reference node.</li><li>`v` : the potential variable between nodes.</li><li>`i` : the flow variable between nodes.</li></ul>
<h1>Returns</h1>
<ul><li>`::Array{Equation}` : the model, consisting of a RefBranch entry for each node and an equation assigning `v` to `n1 - n2`.</li></ul>
<h1>References</h1>
<p>This nodal description is based on work by [David Broman](http://web.ict.kth.se/~dbro/). See the following:</p>
<ul><li>http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-173.pdf</li><li>http://www.bromans.com/software/mkl/mkl-source-1.0.0.zip</li><li>https://github.com/david-broman/modelyze</li></ul>
<h1>Examples</h1>
<p>Here is the definition of an electrical resistor in the standard library:</p>
<pre><code>function Resistor(n1::ElectricalNode, n2::ElectricalNode, R::Signal)
    i = Current(compatible_values(n1, n2))
    v = Voltage(value(n1) - value(n2))
    @equations begin
        Branch(n1, n2, v, i)
        v = R .* i
    end
end</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L759'>Sims/src/main.jl:759</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='BranchHeatPort' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> BranchHeatPort
</div>
<div class='entry-body'>
<p>Wrap argument <code>model</code> with a heat port that captures the power generated by the electrical device. This is vectorizable.</p>
<pre><code>BranchHeatPort(n1::ElectricalNode, n2::ElectricalNode, hp::HeatPort,
               model::Function, args...)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`hp::HeatPort` : Heat port [K]                </li><li>`model::Function` : Model to wrap</li><li>`args...` : Arguments passed to `model`  </li></ul>
<h1>Examples</h1>
<p>Here's an example of a definition defining a Resistor that uses a heat port (a Temperature) in terms of another model:</p>
<pre><code>function Resistor(n1::ElectricalNode, n2::ElectricalNode, R::Signal, hp::Temperature, T_ref::Signal, alpha::Signal) 
    BranchHeatPort(n1, n2, hp, Resistor, R .* (1 + alpha .* (hp - T_ref)))
end</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L158'>Sims/src/electrical.jl:158</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Capacitor' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> Capacitor
</div>
<div class='entry-body'>
<p>The linear capacitor connects the branch voltage <code>v</code> with the branch current <code>i</code> by <code>i = C * dv/dt</code>. </p>
<pre><code>Capacitor(n1::ElectricalNode, n2::ElectricalNode, C::Signal = 1.0) 
Capacitor(n1::ElectricalNode, n2::ElectricalNode; C::Signal = 1.0) </code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`C::Signal` : Capacitance [F], default = 1.0 F</li></ul>
<h1>Details</h1>
<p><code>C</code> can be a constant numeric value or an Unknown, meaning it can vary with time. If <code>C</code> is a constant, it may be positive, zero, or negative. If <code>C</code> is a signal, it should be greater than zero.</p>
<p>This device is vectorizable using array inputs for one or both of <code>n1</code> and <code>n2</code>.</p>
<h1>Example</h1>
<pre><code>function model()
    n1 = Voltage("n1")
    g = 0.0
    Equation[
        SineVoltage(n1, g, 100.0)
        Resistor(n1, g, 3.0)
        Capacitor(n1, g, 1.0)
    ]
end</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L312'>Sims/src/electrical.jl:312</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='ControlledCloserWithArc' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> ControlledCloserWithArc
</div>
<div class='entry-body'>
<p>This model is the same as ControlledOpenerWithArc, but the switch is closed when <code>control > level</code>. </p>
<pre><code>ControlledCloserWithArc(n1::ElectricalNode, n2::ElectricalNode, control::Signal,
                        level = 0.5,  Ron = 1e-5,  Goff = 1e-5,  V0 = 30.0,  dVdt = 10e3,  Vmax = 60.0)
ControlledCloserWithArc(n1::ElectricalNode, n2::ElectricalNode, control::Signal;
                        level = 0.5,  Ron = 1e-5,  Goff = 1e-5,  V0 = 30.0,  dVdt = 10e3,  Vmax = 60.0)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`control::Signal` : `control > level` the switch is closed, otherwise open</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`level` : Switch level [V], default = 0.5</li><li>`Ron` : Closed switch resistance [Ohm], default = 1.E-5</li><li>`Goff` : Opened switch conductance [S], default = 1.E-5</li><li>`V0` : Initial arc voltage [V], default = 30.0</li><li>`dVdt` : Arc voltage slope [V/s], default = 10e3</li><li>`Vmax` : Max. arc voltage [V], default = 60.0</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L1018'>Sims/src/electrical.jl:1018</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='ControlledIdealClosingSwitch' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> ControlledIdealClosingSwitch
</div>
<div class='entry-body'>
<p>TBD </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L879'>Sims/src/electrical.jl:879</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='ControlledIdealOpeningSwitch' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> ControlledIdealOpeningSwitch
</div>
<div class='entry-body'>
<p>TBD </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L856'>Sims/src/electrical.jl:856</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='ControlledOpenerWithArc' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> ControlledOpenerWithArc
</div>
<div class='entry-body'>
<p>This model is an extension to the <code>IdealOpeningSwitch</code>.</p>
<p>The basic model interupts the current through the switch in an infinitesimal time span. If an inductive circuit is connected, the voltage across the switch is limited only by numerics. In order to give a better idea for the voltage across the switch, a simple arc model is added:</p>
<p>When the Boolean input <code>control</code> signals to open the switch, a voltage across the opened switch is impressed. This voltage starts with <code>V0</code> (simulating the voltage drop of the arc roots), then rising with slope <code>dVdt</code> (simulating the rising voltage of an extending arc) until a maximum voltage <code>Vmax</code> is reached.</p>
<pre><code>     | voltage
Vmax |      +-----
     |     /
     |    /
V0   |   +
     |   |
     +---+-------- time</code></pre>
<p>This arc voltage tends to lower the current following through the switch; it depends on the connected circuit, when the arc is quenched. Once the arc is quenched, i.e., the current flowing through the switch gets zero, the equation for the off-state is activated <code>i=Goff*v</code>.</p>
<p>When the Boolean input <code>control</code> signals to close the switch again, the switch is closed immediately, i.e., the equation for the on-state is activated <code>v=Ron*i</code>.</p>
<p>Please note: In an AC circuit, at least the arc quenches when the next natural zero-crossing of the current occurs. In a DC circuit, the arc will not quench if the arc voltage is not sufficient that a zero-crossing of the current occurs.</p>
<p>This model is the same as ControlledOpenerWithArc, but the switch is closed when <code>control > level</code>. </p>
<pre><code>ControlledOpenerWithArc(n1::ElectricalNode, n2::ElectricalNode, control::Signal,
                        level = 0.5,  Ron = 1e-5,  Goff = 1e-5,  V0 = 30.0,  dVdt = 10e3,  Vmax = 60.0)
ControlledOpenerWithArc(n1::ElectricalNode, n2::ElectricalNode, control::Signal;
                        level = 0.5,  Ron = 1e-5,  Goff = 1e-5,  V0 = 30.0,  dVdt = 10e3,  Vmax = 60.0)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`control::Signal` : `control > level` the switch is opened, otherwise closed</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`level` : Switch level [V], default = 0.5</li><li>`Ron` : Closed switch resistance [Ohm], default = 1.E-5</li><li>`Goff` : Opened switch conductance [S], default = 1.E-5</li><li>`V0` : Initial arc voltage [V], default = 30.0</li><li>`dVdt` : Arc voltage slope [V/s], default = 10e3</li><li>`Vmax` : Max. arc voltage [V], default = 60.0</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L952'>Sims/src/electrical.jl:952</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Diode' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> Diode
</div>
<div class='entry-body'>
<p>The simple diode is a one port. It consists of the diode itself and an parallel ohmic resistance <code>R</code>. The diode formula is:</p>
<pre><code>i  =  ids * ( e^(v/vt) - 1 )</code></pre>
<p>If the exponent <code>v/vt</code> reaches the limit <code>maxex</code>, the diode characterisic is linearly continued to avoid overflow.</p>
<pre><code>Diode(n1::ElectricalNode, n2::ElectricalNode, 
      Ids = 1e-6,  Vt = 0.04,  Maxexp = 15,  R = 1e8)
Diode(n1::ElectricalNode, n2::ElectricalNode; 
      Ids = 1e-6,  Vt = 0.04,  Maxexp = 15,  R = 1e8)
Diode(n1::ElectricalNode, n2::ElectricalNode, hp::HeatPort,
      Ids = 1e-6,  Vt = 0.04,  Maxexp = 15,  R = 1e8)
Diode(n1::ElectricalNode, n2::ElectricalNode; hp::HeatPort;
      Ids = 1e-6,  Vt = 0.04,  Maxexp = 15,  R = 1e8)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`hp::HeatPort` : Heat port [K]                </li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`Ids` : Saturation current [A], default = 1.e-6</li><li>`Vt` : Voltage equivalent of temperature (kT/qn) [V], default = 0.04</li><li>`Maxexp` : Max. exponent for linear continuation, default = 15.0</li><li>`R` : Parallel ohmic resistance [Ohm], default = 1.e8</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L1067'>Sims/src/electrical.jl:1067</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='EMF' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> EMF
</div>
<div class='entry-body'>
<p>EMF transforms electrical energy into rotational mechanical energy. It is used as basic building block of an electrical motor. The mechanical connector <code>flange</code> can be connected to elements of the rotational library. </p>
<pre><code>EMF(n1::ElectricalNode, n2::ElectricalNode, flange::Flange,
    support_flange = 0.0, k = 1.0)
EMF(n1::ElectricalNode, n2::ElectricalNode, flange::Flange;
    support_flange = 0.0, k = 1.0)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`flange::Flange` : Rotational shaft</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`support_flange` : Support/housing of the EMF shaft </li><li>`k` : Transformation coefficient [N.m/A] </li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L527'>Sims/src/electrical.jl:527</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='HeatingDiode' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> HeatingDiode
</div>
<div class='entry-body'>
<p>The simple diode is an electrical one port, where a heat port is added, which is defined in the Thermal library. It consists of the diode itself and an parallel ohmic resistance <code>R</code>. The diode formula is:</p>
<pre><code>i  =  ids * ( e^(v/vt_t) - 1 )</code></pre>
<p>where <code>vt_t</code> depends on the temperature of the heat port:</p>
<pre><code>vt_t = k*temp/q</code></pre>
<p>If the exponent <code>v/vt_t</code> reaches the limit <code>maxex</code>, the diode characterisic is linearly continued to avoid overflow. The thermal power is calculated by <code>i*v</code>.</p>
<pre><code>HeatingDiode(n1::ElectricalNode, n2::ElectricalNode, 
             T = 293.15,  Ids = 1e-6,  Maxexp = 15,  R = 1e8,  EG = 1.11,  N = 1.0,  TNOM = 300.15,  XTI = 3.0)
HeatingDiode(n1::ElectricalNode, n2::ElectricalNode; 
             T = 293.15,  Ids = 1e-6,  Maxexp = 15,  R = 1e8,  EG = 1.11,  N = 1.0,  TNOM = 300.15,  XTI = 3.0)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`T` : Heat port [K], default = 293.15</li><li>`Ids` : Saturation current [A], default = 1.e-6</li><li>`Maxexp` : Max. exponent for linear continuation, default = 15.0</li><li>`R` : Parallel ohmic resistance [Ohm], default = 1.e8</li><li>`EG` : Activation energy, default = 1.11</li><li>`N` : Emmission coefficient, default = 1.0</li><li>`TNOM` : Parameter measurement temperature [K], default = 300.15</li><li>`XTI` : Temperature exponent of saturation current, default = 3.0</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L1155'>Sims/src/electrical.jl:1155</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='IdealClosingSwitch' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> IdealClosingSwitch
</div>
<div class='entry-body'>
<p>The ideal closing switch has a positive pin <code>p</code> and a negative pin <code>n</code>. The switching behaviour is controlled by input signal <code>control</code>. If control is true, pin p is connected with negative pin n. Otherwise, pin p is not connected with negative pin n.</p>
<p>In order to prevent singularities during switching, the opened switch has a (very low) conductance <code>Goff</code> and the closed switch has a (very low) resistance <code>Ron</code>. The limiting case is also allowed, i.e., the resistance Ron of the closed switch could be exactly zero and the conductance Goff of the open switch could be also exactly zero. Note, there are circuits, where a description with zero Ron or zero Goff is not possible.</p>
<pre><code>IdealClosingSwitch(n1::ElectricalNode, n2::ElectricalNode, control::Discrete,
                   Ron = 1e-5, Goff = 1e-5)
IdealClosingSwitch(n1::ElectricalNode, n2::ElectricalNode, control::Discrete;
                   Ron = 1e-5, Goff = 1e-5)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`control::Discrete` : true => n1-n2 connected, false => switch open</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`Ron` : Closed switch resistance [Ohm], default = 1.E-5</li><li>`Goff` : Opened switch conductance [S], default = 1.E-5</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L836'>Sims/src/electrical.jl:836</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='IdealDiode' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> IdealDiode
</div>
<div class='entry-body'>
<p>This is an ideal switch which is <strong>open</strong> (off), if it is reversed biased (voltage drop less than 0) <strong>closed</strong> (on), if it is conducting (<code>current > 0</code>). This is the behaviour if all parameters are exactly zero. Note, there are circuits, where this ideal description with zero resistance and zero cinductance is not possible. In order to prevent singularities during switching, the opened diode has a small conductance <code>Gon</code> and the closed diode has a low resistance <code>Roff</code> which is default.</p>
<p>The parameter <code>Vknee</code> which is the forward threshold voltage, allows to displace the knee point along the <code>Gon</code>-characteristic until `v = Vknee`. </p>
<pre><code>IdealDiode(n1::ElectricalNode, n2::ElectricalNode, 
           Vknee = 0.0, Ron = 1e-5, Goff = 1e-5)
IdealDiode(n1::ElectricalNode, n2::ElectricalNode; 
           Vknee = 0.0, Ron = 1e-5, Goff = 1e-5)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`Vknee` : Forward threshold voltage [V], default = 0.0</li><li>`Ron` : Closed diode resistance [Ohm], default = 1.E-5</li><li>`Goff` : Opened diode conductance [S], default = 1.E-5</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L589'>Sims/src/electrical.jl:589</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='IdealGTOThyristor' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> IdealGTOThyristor
</div>
<div class='entry-body'>
<p>This is an ideal GTO thyristor model which is <strong>open</strong> (off), if the voltage drop is less than 0 or <code>fire</code> is false <strong>closed</strong> (on), if the voltage drop is greater or equal 0 and <code>fire</code> is true.</p>
<p>This is the behaviour if all parameters are exactly zero.  Note, there are circuits, where this ideal description with zero resistance and zero cinductance is not possible. In order to prevent singularities during switching, the opened thyristor has a small conductance <code>Goff</code> and the closed thyristor has a low resistance <code>Ron</code> which is default.</p>
<p>The parameter <code>Vknee</code> which is the forward threshold voltage, allows to displace the knee point along the <code>Goff</code>-characteristic until `v = Vknee`.</p>
<pre><code>IdealGTOThyristor(n1::ElectricalNode, n2::ElectricalNode, fire::Discrete, 
                  Vknee = 0.0, Ron = 1e-5, Goff = 1e-5)
IdealGTOThyristor(n1::ElectricalNode, n2::ElectricalNode, fire::Discrete; 
                  Vknee = 0.0, Ron = 1e-5, Goff = 1e-5)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`fire::Discrete` : Discrete bool variable indicating firing of the thyristor</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`Vknee` : Forward threshold voltage [V], default = 0.0</li><li>`Ron` : Closed thyristor resistance [Ohm], default = 1.E-5</li><li>`Goff` : Opened thyristor conductance [S], default = 1.E-5</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L698'>Sims/src/electrical.jl:698</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='IdealOpAmp' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> IdealOpAmp
</div>
<div class='entry-body'>
<p>The ideal OpAmp is a two-port device. The left port is fixed to <code>v1=0</code> and <code>i1=0</code> (nullator). At the right port, both any voltage <code>v2</code> and any current <code>i2</code> are possible (norator).</p>
<p>The ideal OpAmp with three pins is of exactly the same behaviour as the ideal OpAmp with four pins. Only the negative output pin is left out. Both the input voltage and current are fixed to zero (nullator). At the output pin both any voltage <code>v2</code> and any current <code>i2</code> are possible.</p>
<pre><code>IdealOpAmp(p1::ElectricalNode, n1::ElectricalNode, p2::ElectricalNode, n2::ElectricalNode)
IdealOpAmp(p1::ElectricalNode, n1::ElectricalNode, p2::ElectricalNode)</code></pre>
<h1>Arguments</h1>
<ul><li>`p1::ElectricalNode` : Positive electrical node of the left port (potential `p1 > n1` for positive voltage drop v1) [V]</li><li>`n1::ElectricalNode` : Negative electrical node of the left port [V]</li><li>`p2::ElectricalNode` : Positive electrical node of the right port (potential `p2 > n2` for positive voltage drop v2) [V]</li><li>`n2::ElectricalNode` : Negative electrical node of the right port [V], defaults to 0.0 V</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L740'>Sims/src/electrical.jl:740</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='IdealOpeningSwitch' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> IdealOpeningSwitch
</div>
<div class='entry-body'>
<p>The ideal opening switch has a positive pin <code>p</code> and a negative pin <code>n</code>. The switching behaviour is controlled by the input signal <code>control</code>. If control is true, pin p is not connected with negative pin n. Otherwise, pin p is connected with negative pin n.</p>
<p>In order to prevent singularities during switching, the opened switch has a (very low) conductance <code>Goff</code> and the closed switch has a (very low) resistance <code>Ron</code>. The limiting case is also allowed, i.e., the resistance Ron of the closed switch could be exactly zero and the conductance Goff of the open switch could be also exactly zero. Note, there are circuits, where a description with zero Ron or zero Goff is not possible.</p>
<pre><code>IdealOpeningSwitch(n1::ElectricalNode, n2::ElectricalNode, control::Discrete,
                   Ron = 1e-5, Goff = 1e-5)
IdealOpeningSwitch(n1::ElectricalNode, n2::ElectricalNode, control::Discrete;
                   Ron = 1e-5, Goff = 1e-5)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`control::Discrete` : true => switch open, false => n1-n2 connected</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`Ron` : Closed switch resistance [Ohm], default = 1.E-5</li><li>`Goff` : Opened switch conductance [S], default = 1.E-5</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L788'>Sims/src/electrical.jl:788</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='IdealThyristor' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> IdealThyristor
</div>
<div class='entry-body'>
<p>This is an ideal thyristor model which is <strong>open</strong> (off), if the voltage drop is less than 0 or <code>fire</code> is false <strong>closed</strong> (on), if the voltage drop is greater or equal 0 and <code>fire</code> is true.</p>
<p>This is the behaviour if all parameters are exactly zero. Note, there are circuits, where this ideal description with zero resistance and zero cinductance is not possible. In order to prevent singularities during switching, the opened thyristor has a small conductance <code>Goff</code> and the closed thyristor has a low resistance <code>Ron</code> which is default.</p>
<p>The parameter <code>Vknee</code> which is the forward threshold voltage, allows to displace the knee point along the <code>Goff</code>-characteristic until `v = Vknee`. </p>
<pre><code>IdealThyristor(n1::ElectricalNode, n2::ElectricalNode, fire::Discrete, 
               Vknee = 0.0, Ron = 1e-5, Goff = 1e-5)
IdealThyristor(n1::ElectricalNode, n2::ElectricalNode, fire::Discrete; 
               Vknee = 0.0, Ron = 1e-5, Goff = 1e-5)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`fire::Discrete` : Discrete bool variable indicating firing of the thyristor</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`Vknee` : Forward threshold voltage [V], default = 0.0</li><li>`Ron` : Closed thyristor resistance [Ohm], default = 1.E-5</li><li>`Goff` : Opened thyristor conductance [S], default = 1.E-5</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L642'>Sims/src/electrical.jl:642</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Inductor' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> Inductor
</div>
<div class='entry-body'>
<p>The linear inductor connects the branch voltage <code>v</code> with the branch current <code>i</code> by <code>v = L * di/dt</code>. </p>
<pre><code>Inductor(n1::ElectricalNode, n2::ElectricalNode, L::Signal = 1.0) 
Inductor(n1::ElectricalNode, n2::ElectricalNode; L::Signal = 1.0)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`L::Signal` : Inductance [H], default = 1.0 H</li></ul>
<h1>Details</h1>
<p><code>L</code> can be a constant numeric value or an Unknown, meaning it can vary with time. If <code>L</code> is a constant, it may be positive, zero, or negative. If <code>L</code> is a signal, it should be greater than zero.</p>
<p>This device is vectorizable using array inputs for one or both of <code>n1</code> and <code>n2</code></p>
<h1>Example</h1>
<pre><code>function model()
    n1 = Voltage("n1")
    g = 0.0
    Equation[
        SineVoltage(n1, g, 100.0)
        Resistor(n1, g, 3.0)
        Inductor(n1, g, 6.0)
    ]
end</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L367'>Sims/src/electrical.jl:367</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Resistor' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> Resistor
</div>
<div class='entry-body'>
<p>The linear resistor connects the branch voltage <code>v</code> with the branch current <code>i</code> by <code>i*R = v</code>. The Resistance <code>R</code> is allowed to be positive, zero, or negative. </p>
<pre><code>Resistor(n1::ElectricalNode, n2::ElectricalNode, R::Signal)
Resistor(n1::ElectricalNode, n2::ElectricalNode, 
         R = 1.0, T = 293.15, T_ref = 300.15, alpha = 0.0)
Resistor(n1::ElectricalNode, n2::ElectricalNode;             # keyword-arg version
         R = 1.0, T = 293.15, T_ref = 300.15, alpha = 0.0)
Resistor(n1::ElectricalNode, n2::ElectricalNode,
         R::Signal, hp::Temperature, T_ref::Signal, alpha::Signal) </code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`R::Signal` : Resistance at temperature `T_ref` [ohms], default = 1.0 ohms</li><li>`hp::HeatPort` : Heat port [K], optional                </li><li>`T::HeatPort` : Fixed device temperature or HeatPort [K], default = `T_ref`</li><li>`T_ref::Signal` : Reference temperature [K], default = 300.15K</li><li>`alpha::Signal` : Temperature coefficient of resistance (`R_actual = R*(1 + alpha*(T_heatPort - T_ref))`) [1/K], default = 0.0</li></ul>
<h1>Details</h1>
<p>The resistance <code>R</code> is optionally temperature dependent according to the following equation:</p>
<pre><code>R = R_ref*(1 + alpha*(heatPort.T - T_ref))
    </code></pre>
<p>With the optional <code>hp</code> HeatPort argument, the power will be dissipated into this HeatPort.</p>
<p>The resistance <code>R</code> can be a constant numeric value or an Unknown, meaning it can vary with time. <em>Note</em>: it is recommended that the R signal should not cross the zero value. Otherwise, depending on the surrounding circuit, the probability of singularities is high.</p>
<p>This device is vectorizable using array inputs for one or both of <code>n1</code> and <code>n2</code>.</p>
<h1>Example</h1>
<pre><code>function model()
    n1 = Voltage("n1")
    g = 0.0
    Equation[
        SineVoltage(n1, g, 100.0)
        Resistor(n1, g, R = 3.0, T = 330.0, alpha = 1.0)
    ]
end
y = sim(model())</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L244'>Sims/src/electrical.jl:244</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='SaturatingInductor' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> SaturatingInductor
</div>
<div class='entry-body'>
<p>TBD </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L382'>Sims/src/electrical.jl:382</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='SeriesProbe' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> SeriesProbe
</div>
<div class='entry-body'>
<p>Connect a series current probe between two nodes. This is vectorizable.</p>
<pre><code>SeriesProbe(n1, n2, name::String)</code></pre>
<h3>Arguments</h3>
<ul><li>`n1` : Positive node</li><li>`n2` : Negative node</li><li>`name::String` : The name of the probe</li></ul>
<h3>Example</h3>
<pre><code>function model()
    n1 = Voltage("n1")
    n2 = Voltage()
    g = 0.0
    Equation[
        SineVoltage(n1, g, 100.0)
        SeriesProbe(n1, n2, "current")
        Resistor(n2, g, 2.0)
    ]
end
y = sim(model())</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L119'>Sims/src/electrical.jl:119</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='SignalCurrent' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> SignalCurrent
</div>
<div class='entry-body'>
<p>The signal current source is a parameterless converter of real valued signals into a current voltage.</p>
<p>This current source may be vectorized.</p>
<pre><code>SignalCurrent(n1::ElectricalNode, n2::ElectricalNode, I::Signal)  </code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`I::Signal` : Current flowing from n1 to n2 as an input signal</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L1301'>Sims/src/electrical.jl:1301</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='SignalVoltage' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> SignalVoltage
</div>
<div class='entry-body'>
<p>The signal voltage source is a parameterless converter of real valued signals into a source voltage.</p>
<p>This voltage source may be vectorized.</p>
<pre><code>SignalVoltage(n1::ElectricalNode, n2::ElectricalNode, V::Signal)  </code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li><li>`V::Signal` : Voltage between n1 and n2 (= n1 - n2) as an input signal</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L1197'>Sims/src/electrical.jl:1197</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='SineVoltage' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> SineVoltage
</div>
<div class='entry-body'>
<p>A sinusoidal voltage source. An offset parameter is introduced, which is added to the value calculated by the blocks source. The startTime parameter allows to shift the blocks source behavior on the time axis.</p>
<p>This voltage source may be vectorized.</p>
<pre><code>SineVoltage(n1::ElectricalNode, n2::ElectricalNode, 
            V = 1.0,  f = 1.0,  ang = 0.0,  offset = 0.0)
SineVoltage(n1::ElectricalNode, n2::ElectricalNode; 
            V = 1.0,  f = 1.0,  ang = 0.0,  offset = 0.0)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`V` : Amplitude of sine wave [V], default = 1.0</li><li>`phase` : Phase of sine wave [rad], default = 0.0</li><li>`freqHz` : Frequency of sine wave [Hz], default = 1.0</li><li>`offset` : Voltage offset [V], default = 0.0</li><li>`startTime` : Time offset [s], default = 0.0</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L1234'>Sims/src/electrical.jl:1234</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='StepVoltage' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> StepVoltage
</div>
<div class='entry-body'>
<p>A step voltage source. An event is introduced at the transition. Probably cannot be vectorized.</p>
<pre><code>StepVoltage(n1::ElectricalNode, n2::ElectricalNode, 
            V = 1.0,  start = 0.0,  offset = 0.0)
StepVoltage(n1::ElectricalNode, n2::ElectricalNode; 
            V = 1.0,  start = 0.0,  offset = 0.0)</code></pre>
<h1>Arguments</h1>
<ul><li>`n1::ElectricalNode` : Positive electrical node [V]</li><li>`n2::ElectricalNode` : Negative electrical node [V]</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`V` : Height of step [V], default = 1.0</li><li>`offset` : Voltage offset [V], default = 0.0</li><li>`startTime` : Time offset [s], default = 0.0</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L1266'>Sims/src/electrical.jl:1266</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Transformer' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> Transformer
</div>
<div class='entry-body'>
<p>The transformer is a two port. The left port voltage <code>v1</code>, left port current <code>i1</code>, right port voltage <code>v2</code> and right port current <code>i2</code> are connected by the following relation:</p>
<pre><code>| v1 |         | L1   M  |  | i1' |
|    |    =    |         |  |     |
| v2 |         | M    L2 |  | i2' |</code></pre>
<p><code>L1</code>, <code>L2</code>, and <code>M</code> are the primary, secondary, and coupling inductances respectively.</p>
<pre><code>Transformer(p1::ElectricalNode, n1::ElectricalNode, p2::ElectricalNode, n2::ElectricalNode, 
            L1 = 1.0, L2 = 1.0, M = 1.0)
Transformer(p1::ElectricalNode, n1::ElectricalNode, p2::ElectricalNode, n2::ElectricalNode; 
            L1 = 1.0, L2 = 1.0, M = 1.0)</code></pre>
<h1>Arguments</h1>
<ul><li>`p1::ElectricalNode` : Positive electrical node of the left port (potential `p1 > n1` for positive voltage drop v1) [V]</li><li>`n1::ElectricalNode` : Negative electrical node of the left port [V]</li><li>`p2::ElectricalNode` : Positive electrical node of the right port (potential `p2 > n2` for positive voltage drop v2) [V]</li><li>`n2::ElectricalNode` : Negative electrical node of the right port [V]</li></ul>
<h1>Keyword/Optional Arguments</h1>
<ul><li>`L1::Signal` : Primary inductance [H], default = 1.0 H</li><li>`L2::Signal` : Secondary inductance [H], default = 1.0 H</li><li>`M::Signal`  : Coupling inductance [H], default = 1.0 H</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L483'>Sims/src/electrical.jl:483</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='ZDiode' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> ZDiode
</div>
<div class='entry-body'>
<p>TBD </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L1092'>Sims/src/electrical.jl:1092</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='addhook!' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> addhook!
</div>
<div class='entry-body'>
<p>Add hooks to a Discrete variable.</p>
<p>The propagation and handling of Discrete variables is currently rather simple. It would be nice for Discrete variables to handle data flows like a reactive programming system. This allows for a simple way to add some value propagation.</p>
<h1>Arguments</h1>
<ul><li>`d::Discrete` : the discrete variable.</li><li>`ex::ModelType` : the value of the delay; may be an object or Unknown.</li></ul>
<h1>Returns</h1>
<ul><li>`Void`</li></ul>
<h1>Examples</h1>
<pre><code>function test_BoolEventHook()
    n1 = Voltage("n1")
    sig2 = Discrete(true)
    sig = Discrete(false)
    Sims.addhook!(sig, 
             reinit(sig2, false))
    g = 0.0
    Equation[
        SineVoltage(n1, g, ifelse(sig2, 10.0, 5.0), ifelse(sig, 1.0, 2.0)) 
        BoolEvent(sig, MTime - 0.25)  
        Resistor(n1, g, 1e-3)
    ]
end
y = sim(test_BoolEventHook())</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L991'>Sims/src/main.jl:991</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='check' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> check
</div>
<div class='entry-body'>
<p>Prints the number of equations and the number of unknowns.</p>
<pre><code>name(x)</code></pre>
<h1>Arguments</h1>
<ul><li>`x` : a Model, EquationSet, or Sim</li></ul>
<h1>Returns</h1>
<ul><li>`::Void`</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/utils.jl#L22'>Sims/src/utils.jl:22</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='compatible_values' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> compatible_values
</div>
<div class='entry-body'>
<p>A helper functions to return the base value from an Unknown to use when creating other Unknowns. It is especially useful for taking two model arguments and creating a new Unknown compatible with both arguments.</p>
<pre><code>compatible_values(x,y)
compatible_values(x)</code></pre>
<p>It's still somewhat broken but works for basic cases. No type promotion is currently done.</p>
<h1>Arguments</h1>
<ul><li>`x`, `y` : objects or Unknowns</li></ul>
<h1>Returns</h1>
<p>The returned object has zeros of type and length common to both <code>x</code> and <code>y</code>.</p>
<h1>Examples</h1>
<pre><code>a = Unknown(45.0 + 10im)
x = Unknown(compatible_values(a))   # Initialized to 0.0 + 0.0im.
a = Unknown()
b = Unknown([1., 0.])
y = Unknown(compatible_values(a,b)) # Initialized to [0.0, 0.0].</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L632'>Sims/src/main.jl:632</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='create_sim' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> create_sim
</div>
<div class='entry-body'>
<p><code>create_sim</code> converts a model to a Sim.</p>
<pre><code>create_sim(m::Model)
create_sim(eq::EquationSet)</code></pre>
<h1>Arguments</h1>
<ul><li>`m::Model` : a Model</li><li>`eq::EquationSet` : a flattened model</li></ul>
<h1>Returns</h1>
<ul><li>`::Sim` : a simulation object</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/simcreation.jl#L97'>Sims/src/simcreation.jl:97</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='create_simstate' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> create_simstate
</div>
<div class='entry-body'>
<p><code>create_simstate</code> converts a Sim is the main conversion function that returns a SimState, a simulation object with state history.</p>
<pre><code>create_simstate(m::Model)
create_simstate(eq::EquationSet)
create_simstate(sm::Sim)</code></pre>
<h1>Arguments</h1>
<ul><li>`m::Model` : a Model</li><li>`eq::EquationSet` : a flattened model</li><li>`sm::Sim` : a simulation object</li></ul>
<h1>Returns</h1>
<ul><li>`::Sim` : a simulation object</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/simcreation.jl#L141'>Sims/src/simcreation.jl:141</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='delay' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> delay
</div>
<div class='entry-body'>
<p>A Model specifying a delay to an Unknown.</p>
<p>Internally, Unknowns that are delayed store past history. This is interpolated as needed to find the delayed quantity.</p>
<pre><code>delay(x::Unknown, val)</code></pre>
<h1>Arguments</h1>
<ul><li>`x::Unknown` : the quantity to be delayed.</li><li>`val` : the value of the delay; may be an object or Unknown.</li></ul>
<h1>Returns</h1>
<ul><li>`::MExpr` : a delayed Unknown</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L870'>Sims/src/main.jl:870</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='der' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> der
</div>
<div class='entry-body'>
<p>Represents the derivative of an Unknown.</p>
<pre><code>der(x::Unknown)
der(x::Unknown, val)</code></pre>
<h1>Arguments</h1>
<ul><li>`x::Unknown` : the Unknown variable</li><li>`val` : initial value, defaults to 0.0</li></ul>
<h1>Examples</h1>
<pre><code>a = Unknown()
der(a) + 1</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L287'>Sims/src/main.jl:287</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='elaborate' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> elaborate
</div>
<div class='entry-body'>
<p><code>elaborate</code> is the main elaboration function that returns a flattened model representation that can be used by <code>sim</code>.</p>
<pre><code>elaborate(a::Model)</code></pre>
<h1>Arguments</h1>
<ul><li>`a::Model` : the input model</li></ul>
<h1>Returns</h1>
<ul><li>`::EquationSet` : the flattened model</li></ul>
<h1>Details</h1>
<p>The main steps in flattening are:</p>
<ul><li>Replace fixed initial values.</li><li>Flatten models and populate `eq.equations`.</li><li>Pull out InitialEquations and populate `eq.initialequations`.</li><li>Pull out Events and populate `eq.events`.</li><li>Handle StructuralEvents.</li><li>Collect nodes and populate `eq.nodeMap`.</li><li>Strip out MExpr's from expressions.</li><li>Remove empty equations.</li></ul>
<p>There is currently no real symbolic processing (sorting, index reduction, or any of the other stuff a fancy modeling tool would do).</p>
<p>In EquationSet, <code>model</code> contains equations and StructuralEvents. When a StructuralEvent triggers, the entire model is elaborated again. The first step is to replace StructuralEvents that have activated with their new_relation in model. Then, the rest of the EquationSet is reflattened using <code>model</code> as the starting point. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/elaboration.jl#L69'>Sims/src/elaboration.jl:69</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='ifelse' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> ifelse
</div>
<div class='entry-body'>
<p>A function allowing if-then-else action for objections and expressions.</p>
<p>Note that when this is used in a model, it does not trigger an event. You need to use <code>Event</code> or <code>BoolEvent</code> for that. It is used often in conjunction with <code>Event</code>.</p>
<pre><code>ifelse(x, y)
ifelse(x, y, z)</code></pre>
<h1>Arguments</h1>
<ul><li>`x` : the condition, a Bool or ModelType</li><li>`y` : the value to return when true</li><li>`z` : the value to return when false, defaults to `nothing`</li></ul>
<h1>Returns</h1>
<ul><li>Either `y` or `z`</li></ul>
<h1>Examples</h1>
<p>See DeadZone and Limiter in the standard library.</p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L1201'>Sims/src/main.jl:1201</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='is_unknown' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> is_unknown
</div>
<div class='entry-body'>
<p>Is the object an UnknownVariable? </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L238'>Sims/src/main.jl:238</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='mexpr' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> mexpr
</div>
<div class='entry-body'>
<p>Create MExpr's (model expressions). Analogous to <code>expr</code> in Base.</p>
<p>This is also useful for wrapping user-defined functions where the built-in mechanisms don't work.</p>
<pre><code>mexpr(head::Symbol, args::ANY...)</code></pre>
<h1>Arguments</h1>
<ul><li>`head::Symbol` : the expression head</li><li>`args...` : values and expressions passed to expression arguments</li></ul>
<h1>Returns</h1>
<ul><li>`ex::MExpr` : a model expression</li></ul>
<h1>Examples</h1>
<pre><code>a = Unknown()
b = Unknown()
d = a + sin(b)
typeof(d)
myfun(x) = mexpr(:call, :myfun, x)</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L347'>Sims/src/main.jl:347</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='name' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> name
</div>
<div class='entry-body'>
<p>The name of an UnknownVariable.</p>
<pre><code>name(a::UnknownVariable)</code></pre>
<h1>Arguments</h1>
<ul><li>`x::UnknownVariable`</li></ul>
<h1>Returns</h1>
<ul><li>`s::String` : either the label of the Unknown or if that's blank, the symbol name of the Unknown.</li></ul>
<h1>Examples</h1>
<pre><code>a = Unknown("var1")
name(a)</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L592'>Sims/src/main.jl:592</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='pre' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> pre
</div>
<div class='entry-body'>
<p>The value of a Discrete variable <code>x</code> prior to an event.</p>
<p>See also <code>Event</code>.</p>
<pre><code>pre(x::DiscreteVar)</code></pre>
<h1>Arguments</h1>
<ul><li>`x::Discrete`</li></ul>
<h1>Returns</h1>
<ul><li>A value stored just prior to an event.</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L1017'>Sims/src/main.jl:1017</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='reinit' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> reinit
</div>
<div class='entry-body'>
<p><code>reinit</code> is used in Event responses to redefine variables. </p>
<pre><code>reinit(x::DiscreteVar, y)</code></pre>
<h1>Arguments</h1>
<ul><li>`x::UnknownVariable` : the object to be reinitialized.</li><li>`y` : value for redefinition.</li></ul>
<h1>Returns</h1>
<ul><li>A value stored just prior to an event.</li></ul>
<h1>Examples</h1>
<p>Here is the definition of Step in the standard library:</p>
<pre><code>function Step(y::Signal, 
              height = 1.0,
              offset = 0.0, 
              startTime = 0.0)
    ymag = Discrete(offset)
    @equations begin
        y = ymag  
        Event(MTime - startTime,
              Equation[reinit(ymag, offset + height)],   # positive crossing
              Equation[reinit(ymag, offset)])            # negative crossing
    end
end</code></pre>
<p>See also <code>IdealThyristor</code> in the standard library.</p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L1111'>Sims/src/main.jl:1111</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='value' class='entry-name category-function'>
<div class='category'>[function] &mdash; </div> value
</div>
<div class='entry-body'>
<p>The value of an object or UnknownVariable.</p>
<pre><code>value(x)</code></pre>
<h1>Arguments</h1>
<ul><li>`x` : an object</li></ul>
<h1>Returns</h1>
<p>For standard Julia objects, <code>value(x)</code> returns x. For Unknowns and other ModelTypes, returns the current value of the object. <code>value</code> evaluates immediately, so don't expect to use this in model expressions, except to grab an immediate value.</p>
<h1>Examples</h1>
<pre><code>v = Voltage(value(n1) - value(n2))</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L556'>Sims/src/main.jl:556</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='DefaultUnknown' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> DefaultUnknown
</div>
<div class='entry-body'>
<p>The default UnknownCategory. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L145'>Sims/src/main.jl:145</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='DerUnknown' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> DerUnknown
</div>
<div class='entry-body'>
<p>An UnknownVariable representing the derivitive of an Unknown, normally created with <code>der(x)</code>.</p>
<h1>Arguments</h1>
<ul><li>`x::Unknown` : the Unknown variable</li><li>`val` : initial value, defaults to 0.0</li></ul>
<h1>Examples</h1>
<pre><code>a = Unknown()
der(a) + 1
typeof(der(a))</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L257'>Sims/src/main.jl:257</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Discrete' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Discrete
</div>
<div class='entry-body'>
<p>Discrete is a type for discrete variables. These are only changed during events. They are not used by the integrator. Because they are not used by the integrator, almost any type can be used as a discrete variable.</p>
<pre><code>Discrete()
Discrete(x)
Discrete(s::Symbol, label::String)
Discrete(x, label::String)
Discrete(label::String)
Discrete(s::Symbol, x)
Discrete(s::Symbol, x, label::String)</code></pre>
<h1>Arguments</h1>
<ul><li>`s::Symbol` : identification symbol, defaults to `gensym()`</li><li>`value` : initial value and type information, defaults to 0.0</li><li>`label::String` : labeling string, defaults to ""</li></ul>
<h1>Details</h1>
<p>Discrete variables are currently quite limited. You cannot have systems of equations where the values of Discrete variables propagates easily. A crude mechanism for some chaining is provided by <code>addhook!</code>. It would be nice to have data flow support (reactive programming). The package <a href="https://github.com/JuliaLang/Reactive.jl">Reactive.jl</a> may help here.</p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L914'>Sims/src/main.jl:914</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='DiscreteVar' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> DiscreteVar
</div>
<div class='entry-body'>
<p>A helper type used inside of the residual function. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L947'>Sims/src/main.jl:947</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='EquationSet' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> EquationSet
</div>
<div class='entry-body'>
<p>A representation of a flattened model, normally created with <code>elaborate(model)</code>. <code>sim</code> uses an elaborated model for simulations.</p>
<p>Contains the hierarchical equations, flattened equations, flattened initial equations, events, event response functions, and a map of Unknown nodes. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/elaboration.jl#L20'>Sims/src/elaboration.jl:20</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Event' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Event
</div>
<div class='entry-body'>
<p>Event is the main type used for hybrid modeling. It contains a condition for root finding and model expressions to process after positive and negative root crossings are detected.</p>
<p>See also <code>BoolEvent</code>.</p>
<pre><code>Event(condition::ModelType, pos_response, neg_response)</code></pre>
<h1>Arguments</h1>
<ul><li>`condition::ModelType` : an expression used for the event detection.</li><li>`pos_response` : an expression indicating what to do when the condition crosses zero positively. May be Model or MExpr.</li><li>`neg_response::Model` : an expression indicating what to do when the condition crosses zero in the negative direction. Defaults to Equation[].</li></ul>
<h1>Examples</h1>
<p>See <code>IdealThyristor</code> in the standard library.</p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L1045'>Sims/src/main.jl:1045</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='InitialEquation' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> InitialEquation
</div>
<div class='entry-body'>
<p>A ModelType describing initial equations. Current support is limited and may be broken. There are no tests. The idea is that the equations provided will only be used during the initial solution.</p>
<pre><code>InitialEquation(egs)</code></pre>
<h1>Arguments</h1>
<ul><li>`eqs::Array{Equation}` : a vector of equations, each to be equated to zero during the initial equation solution.</li></ul>
<pre><code></code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L788'>Sims/src/main.jl:788</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='LeftVar' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> LeftVar
</div>
<div class='entry-body'>
<p>A helper type needed to mark unknowns as left-side variables in assignments during event responses. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L1069'>Sims/src/main.jl:1069</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='MExpr' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> MExpr
</div>
<div class='entry-body'>
<p>Represents expressions used in models.</p>
<pre><code>MExpr(ex::Expr)</code></pre>
<h1>Arguments</h1>
<ul><li>`ex::Expr` : an expression</li></ul>
<h1>Examples</h1>
<pre><code>a = Unknown()
b = Unknown()
d = a + sin(b)
typeof(d)</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L314'>Sims/src/main.jl:314</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='ModelType' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> ModelType
</div>
<div class='entry-body'>
<p>The main overall abstract type in Sims. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L129'>Sims/src/main.jl:129</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Parameter{T<:UnknownCategory}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Parameter{T<:UnknownCategory}
</div>
<div class='entry-body'>
<p>Represents an Unknown that stays constant through a simulation. Useful for passing in at the top level.</p>
<pre><code>Parameter(s::Symbol, value)
Parameter(value)
Parameter(s::Symbol, label::String)
Parameter(value, label::String)</code></pre>
<h1>Arguments</h1>
<ul><li>`s::Symbol` : identification symbol, defaults to `gensym()`</li><li>`value` : initial value and type information, defaults to 0.0</li><li>`label::String` : labeling string, defaults to ""</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L368'>Sims/src/main.jl:368</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='PassedUnknown' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> PassedUnknown
</div>
<div class='entry-body'>
<p>An UnknownVariable used as a helper for the <code>delay</code> function.  It is an identity unknown, but it doesn't replace with a reference to the y array.</p>
<p>PassedUnknown(ref::UnknownVariable)</p>
<h1>Arguments</h1>
<ul><li>`ref::UnknownVariable` : an Unknown</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L814'>Sims/src/main.jl:814</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='RefBranch' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> RefBranch
</div>
<div class='entry-body'>
<p>A special ModelType to specify branch flows into nodes. When the model is flattened, equations are created to zero out branch flows into nodes. </p>
<p>See also <code>Branch</code>.</p>
<pre><code>RefBranch(n, i) </code></pre>
<h1>Arguments</h1>
<ul><li>`n` : the reference node.</li><li>`i` : the flow variable that goes with this node.</li></ul>
<h1>References</h1>
<p>This nodal description is based on work by [David Broman](http://web.ict.kth.se/~dbro/). See the following:</p>
<ul><li>http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-173.pdf</li><li>http://www.bromans.com/software/mkl/mkl-source-1.0.0.zip</li><li>https://github.com/david-broman/modelyze</li></ul>
<p><a href="https://github.com/david-broman/modelyze">Modelyze</a> has both <code>RefBranch</code> and <code>Branch</code>.</p>
<h1>Examples</h1>
<p>Here is an example of RefBranch used in the definition of a HeatCapacitor in the standard library. <code>hp</code> is the reference node (a HeatPort aka Temperature), and <code>Q_flow</code> is the flow variable.</p>
<pre><code>function HeatCapacitor(hp::HeatPort, C::Signal)
    Q_flow = HeatFlow(compatible_values(hp))
    @equations begin
        RefBranch(hp, Q_flow)
        C .* der(hp) = Q_flow
    end
end</code></pre>
<p>Here is the definition of SignalCurrent from the standard library a model that injects current (a flow variable) between two nodes:</p>
<pre><code>function SignalCurrent(n1::ElectricalNode, n2::ElectricalNode, I::Signal)  
    @equations begin
        RefBranch(n1, I) 
        RefBranch(n2, -I) 
    end
end</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L706'>Sims/src/main.jl:706</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='RefDiscrete' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> RefDiscrete
</div>
<div class='entry-body'>
<p>A helper type for Discretes used in Arrays. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L938'>Sims/src/main.jl:938</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='RefUnknown{T<:UnknownCategory}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> RefUnknown{T<:UnknownCategory}
</div>
<div class='entry-body'>
<p>An UnknownVariable used to allow Arrays as Unknowns. Normally created with <code>getindex</code>. Defined methods include:</p>
<ul><li>getindex</li><li>length</li><li>size</li><li>hcat</li><li>vcat</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L521'>Sims/src/main.jl:521</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Sim' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Sim
</div>
<div class='entry-body'>
<p>A type for holding several simulation objects needed for simulation, normally created with <code>create_sim(eqs)</code>.  </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/simcreation.jl#L42'>Sims/src/simcreation.jl:42</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='SimFunctions' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> SimFunctions
</div>
<div class='entry-body'>
<p>The set of functions used in the DAE solution. Includes an initial set of equations, a residual function, and several functions for detecting and responding to events.</p>
<p>All functions take (t,y,yp) as arguments. {TODO: is this still right?} </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/simcreation.jl#L24'>Sims/src/simcreation.jl:24</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='SimResult' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> SimResult
</div>
<div class='entry-body'>
<p>A type holding simulation results from <code>sim</code>, <code>dasslsim</code>, or <code>sunsim</code>. Includes a matrix of results and a vector of column names. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/simcreation.jl#L427'>Sims/src/simcreation.jl:427</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='SimState' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> SimState
</div>
<div class='entry-body'>
<p>The top level type for holding all simulation objects needed for simulation, including a Sim. Normally created with <code>create_simstate(sim)</code>. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/simcreation.jl#L70'>Sims/src/simcreation.jl:70</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='StructuralEvent' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> StructuralEvent
</div>
<div class='entry-body'>
<p>StructuralEvent defines a type for elements that change the structure of the model. An event is created where the condition crosses zero. When the event is triggered, the model is re-flattened after replacing <code>default</code> with <code>new_relation</code> in the model.</p>
<pre><code>StructuralEvent(condition::MExpr, default, new_relation::Function)</code></pre>
<h1>Arguments</h1>
<ul><li>`condition::MExpr` : an expression that will trigger the event at a zero crossing</li><li>`default` : the default Model used</li><li>`new_relation` : a function that returns a model that will replace the default model when the condition triggers the event.</li></ul>
<h1>Examples</h1>
<p>Here is an example from examples/breaking_pendulum.jl:</p>
<pre><code>function FreeFall(x,y,vx,vy)
    @equations begin
        der(x) = vx
        der(y) = vy
        der(vx) = 0.0
        der(vy) = -9.81
    end
end

function Pendulum(x,y,vx,vy)
    len = sqrt(x.value^2 + y.value^2)
    phi0 = atan2(x.value, -y.value) 
    phi = Unknown(phi0)
    phid = Unknown()
    @equations begin
        der(phi) = phid
        der(x) = vx
        der(y) = vy
        x = len * sin(phi)
        y = -len * cos(phi)
        der(phid) = -9.81 / len * sin(phi)
    end
end

function BreakingPendulum()
    x = Unknown(cos(pi/4), "x")
    y = Unknown(-cos(pi/4), "y")
    vx = Unknown()
    vy = Unknown()
    Equation[
        StructuralEvent(MTime - 5.0,     # when time hits 5 sec, switch to FreeFall
            Pendulum(x,y,vx,vy),
            () -> FreeFall(x,y,vx,vy))
    ]
end

p_y = sim(BreakingPendulum(), 6.0)  </code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L1280'>Sims/src/main.jl:1280</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UAngle' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UAngle
</div>
<div class='entry-body'>
<p>An UnknownCategory for rotational angle in radians. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L142'>Sims/src/types.jl:142</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UAngularAcceleration' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UAngularAcceleration
</div>
<div class='entry-body'>
<p>An UnknownCategory for angular acceleration in radians/sec^2. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L184'>Sims/src/types.jl:184</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UAngularVelocity' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UAngularVelocity
</div>
<div class='entry-body'>
<p>An UnknownCategory for angular velocity in radians/sec. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L170'>Sims/src/types.jl:170</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UCurrent' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UCurrent
</div>
<div class='entry-body'>
<p>An UnknownCategory for electrical current in amperes. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L43'>Sims/src/types.jl:43</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UHeatFlow' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UHeatFlow
</div>
<div class='entry-body'>
<p>An UnknownCategory for heat flow rate in watts. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L100'>Sims/src/types.jl:100</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UHeatPort' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UHeatPort
</div>
<div class='entry-body'>
<p>An UnknownCategory for temperature in kelvin. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L88'>Sims/src/types.jl:88</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UTemperature' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UTemperature
</div>
<div class='entry-body'>
<p>An UnknownCategory for temperature in kelvin. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L94'>Sims/src/types.jl:94</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UTorque' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UTorque
</div>
<div class='entry-body'>
<p>An UnknownCategory for torque in newton-meters. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L147'>Sims/src/types.jl:147</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UVoltage' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UVoltage
</div>
<div class='entry-body'>
<p>An UnknownCategory for electrical potential in volts. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L38'>Sims/src/types.jl:38</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Union(AbstractArray{T,N},RefUnknown{DefaultUnknown},Unknown{DefaultUnknown},Number,MExpr)' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Union(AbstractArray{T,N},RefUnknown{DefaultUnknown},Unknown{DefaultUnknown},Number,MExpr)
</div>
<div class='entry-body'>
<p><strong>Signal</strong></p>
<p><code>Signal</code> is a typealias for <code>NumberOrUnknown{DefaultUnknown}</code>.</p>
<p>Can be an Unknown, an AbstractArray, a Number, or an MExpr. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L28'>Sims/src/types.jl:28</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Union(AbstractArray{T,N},Unknown{UVoltage},RefUnknown{UVoltage},Number,MExpr)' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Union(AbstractArray{T,N},Unknown{UVoltage},RefUnknown{UVoltage},Number,MExpr)
</div>
<div class='entry-body'>
<p><strong>ElectricalNode</strong></p>
<p><code>ElectricalNode</code> is a typealias for <code>NumberOrUnknown{UVoltage}</code>.</p>
<p>An electrical node, either a Voltage (an Unknown) or a real value. Can include arrays or complex values. Used commonly as a model arguments for nodes. This allows nodes to be Unknowns or fixed values (like a ground that's zero volts). </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L56'>Sims/src/types.jl:56</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Union(RefUnknown{T},Unknown{T},AbstractArray{T,N},Number,MExpr)' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Union(RefUnknown{T},Unknown{T},AbstractArray{T,N},Number,MExpr)
</div>
<div class='entry-body'>
<p><strong>NumberOrUnknown{T}</strong></p>
<p><code>NumberOrUnknown{T}</code> is a typealias for <code>Union(AbstractArray, Number, MExpr, RefUnknown{T}, Unknown{T})</code>.</p>
<p>Can be an Unknown, an AbstractArray, a Number, or an MExpr. Useful where an object can be either an Unknown of a particular type or a real value, especially for use as a type in a model argument. It may be parameterized by an UnknownCategory, like NumberOrUnknown{UVoltage} (the definition of an ElectricalNode). </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L18'>Sims/src/types.jl:18</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Union(RefUnknown{UHeatPort},AbstractArray{T,N},Unknown{UHeatPort},Number,MExpr)' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Union(RefUnknown{UHeatPort},AbstractArray{T,N},Unknown{UHeatPort},Number,MExpr)
</div>
<div class='entry-body'>
<p><strong>HeatPort</strong></p>
<p><code>HeatPort</code> is a typealias for <code>NumberOrUnknown{UHeatPort}</code>.</p>
<p>A thermal node, either a Temperature (an Unknown) or a real value. Can include arrays. Used commonly as a model arguments for nodes. This allows nodes to be Unknowns or fixed values. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L112'>Sims/src/types.jl:112</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Union(Unknown{UAngle},AbstractArray{T,N},Number,MExpr,RefUnknown{UAngle})' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Union(Unknown{UAngle},AbstractArray{T,N},Number,MExpr,RefUnknown{UAngle})
</div>
<div class='entry-body'>
<p><strong>Flange</strong></p>
<p><code>Flange</code> is a typealias for <code>NumberOrUnknown{UAngle}</code>.</p>
<p>A rotational node, either an Angle (an Unknown) or a real value in radians. Can include arrays. Used commonly as a model arguments for nodes. This allows nodes to be Unknowns or fixed values.   </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L206'>Sims/src/types.jl:206</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UnknownCategory' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UnknownCategory
</div>
<div class='entry-body'>
<p>Categories of Unknown types; used to subtype Unknowns. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L140'>Sims/src/main.jl:140</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='UnknownVariable' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> UnknownVariable
</div>
<div class='entry-body'>
<p>An abstract type for variables to be solved. Examples include Unknown, DerUnknown, and Parameter. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L135'>Sims/src/main.jl:135</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Unknown{T<:UnknownCategory}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Unknown{T<:UnknownCategory}
</div>
<div class='entry-body'>
<p>An Unknown represents variables to be solved in Sims. An <code>Unknown</code> is a symbolic type. When used in Julia expressions, Unknowns combine into <code>MExpr</code>s which are symbolic representations of equations.</p>
<p>Expressions (of type MExpr) are built up based on Unknown's. Unknown is a symbol with a uniquely generated symbol name. If you have</p>
<p>Unknowns can contain Float64, Complex, and Array{Float64} values. Additionally, Unknowns can be extended to support other types. All Unknown types currently map to positions in an Array{Float64}.</p>
<p>In addition to a value, Unknowns can carry additional metadata, including an identification symbol and a label. In the future, unit information may be added.</p>
<p>Unknowns can also have type parameters. For example, <code>Voltage</code> is defined as <code>Unknown{UVoltage}</code> in the standard library. The <code>UVoltage</code> type parameter is a marker to distinguish those Unknown from others. Users can add their own Unknown types. Different Unknown types makes it easier to dispatch on model arguments.</p>
<pre><code>Unknown(s::Symbol, x, label::String, fixed::Bool)
Unknown()
Unknown(x)
Unknown(s::Symbol, label::String)
Unknown(x, label::String)
Unknown(label::String)
Unknown(s::Symbol, x, fixed::Bool)
Unknown(s::Symbol, x)
Unknown{T}(s::Symbol, x, label::String, fixed::Bool)
Unknown{T}()
Unknown{T}(x)
Unknown{T}(s::Symbol, label::String)
Unknown{T}(x, label::String)
Unknown{T}(label::String)
Unknown{T}(s::Symbol, x, fixed::Bool)
Unknown{T}(s::Symbol, x)</code></pre>
<h1>Arguments</h1>
<ul><li>`s::Symbol` : identification symbol, defaults to `gensym()`</li><li>`x` : initial value and type information, defaults to 0.0</li><li>`label::String` : labeling string, defaults to ""</li></ul>
<h1>Examples</h1>
<pre><code>  a = 4
  b = Unknown(3.0, "len")
  a * b + b^2</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L203'>Sims/src/main.jl:203</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Unknown{UAngle}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Unknown{UAngle}
</div>
<div class='entry-body'>
<p><strong>Angle</strong></p>
<p><code>Angle</code> is a typealias for <code>Unknown{UAngle}</code>.</p>
<p>The angle in radians. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L156'>Sims/src/types.jl:156</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Unknown{UAngularAcceleration}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Unknown{UAngularAcceleration}
</div>
<div class='entry-body'>
<p><strong>AngularAcceleration</strong></p>
<p><code>AngularAcceleration</code> is a typealias for <code>Unknown{UAngularAcceleration}</code>.</p>
<p>The angular acceleration in radians/sec^2. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L194'>Sims/src/types.jl:194</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Unknown{UAngularVelocity}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Unknown{UAngularVelocity}
</div>
<div class='entry-body'>
<p><strong>AngularVelocity</strong></p>
<p><code>AngularVelocity</code> is a typealias for <code>Unknown{UAngularVelocity}</code>.</p>
<p>The angular velocity in radians/sec. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L179'>Sims/src/types.jl:179</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Unknown{UCurrent}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Unknown{UCurrent}
</div>
<div class='entry-body'>
<p><strong>Current</strong></p>
<p><code>Current</code> is a typealias for <code>Unknown{UCurrent}</code>.</p>
<p>Electrical current with units of amperes. A flow variable. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L77'>Sims/src/types.jl:77</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Unknown{UHeatFlow}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Unknown{UHeatFlow}
</div>
<div class='entry-body'>
<p><strong>HeatFlow</strong></p>
<p><code>HeatFlow</code> is a typealias for <code>Unknown{UHeatFlow}</code>.</p>
<p>Heat flow rate in units of watts. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L121'>Sims/src/types.jl:121</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Unknown{UHeatPort}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Unknown{UHeatPort}
</div>
<div class='entry-body'>
<p><strong>HeatPort</strong></p>
<p><code>HeatPort</code> is a typealias for <code>Unknown{UHeatPort}</code>.</p>
<p>A thermal potential, a Temperature (an Unknown) in units of kelvin. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L130'>Sims/src/types.jl:130</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Unknown{UTorque}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Unknown{UTorque}
</div>
<div class='entry-body'>
<p><strong>Torque</strong></p>
<p><code>Torque</code> is a typealias for <code>Unknown{UTorque}</code>.</p>
<p>The torque in newton-meters. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L165'>Sims/src/types.jl:165</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Unknown{UVoltage}' class='entry-name category-type'>
<div class='category'>[type] &mdash; </div> Unknown{UVoltage}
</div>
<div class='entry-body'>
<p><strong>Voltage</strong></p>
<p><code>Voltage</code> is a typealias for <code>Unknown{UVoltage}</code>.</p>
<p>Electrical potential with units of volts. Used as nodes and potential differences between nodes.</p>
<p>Often used with <code>ElectricalNode</code> as a model argument. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/types.jl#L68'>Sims/src/types.jl:68</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='@equations' class='entry-name category-macro'>
<div class='category'>[macro] &mdash; </div> @equations
</div>
<div class='entry-body'>
<p>A helper to make writing Models a little easier. It allows the use of <code>=</code> in model equations.</p>
<pre><code>@equations begin
    ...
end</code></pre>
<h1>Arguments</h1>
<ul><li>`eq` : the model equations, normally in a `begin` - `end` block.</li></ul>
<h1>Returns</h1>
<ul><li>`::Array{Equation}`</li></ul>
<h1>Examples</h1>
<p>The following are both equivalent:</p>
<pre><code>function Vanderpol1()
    y = Unknown(1.0, "y")
    x = Unknown("x")
    Equation[
        der(x, -1.0) - ((1 - y^2) * x - y)      # == 0 is assumed
        der(y) - x
    ]
end
function Vanderpol2()
    y = Unknown(1.0, "y") 
    x = Unknown("x")
    @equations begin
        der(x, -1.0) = (1 - y^2) * x - y
        der(y) = x
    end
end</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L1374'>Sims/src/main.jl:1374</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='@unknown' class='entry-name category-macro'>
<div class='category'>[macro] &mdash; </div> @unknown
</div>
<div class='entry-body'>
<p>A macro to ease entry of many unknowns.</p>
<pre><code>@unknown a1 a2 a3 ...</code></pre>
<h1>Arguments</h1>
<ul><li>`a` : various representations of Unknowns, several specification options include:</li><li>symbol: equivalent to `symbol = Unknown(symbol)`</li><li>symbol(val): equivalent to `symbol = Unknown(symbol, val)`</li></ul>
<h1>Effects</h1>
<p>Creates one or more Unknowns</p>
<ul><li>A Gadfly object</li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/utils.jl#L227'>Sims/src/utils.jl:227</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Equation' class='entry-name category-global'>
<div class='category'>[global] &mdash; </div> Equation
</div>
<div class='entry-body'>
<p>Equations are used in Models. Right now, Equation is defined as <code>Any</code>, but that may change.  Normally, Equations are of type Unknown, DerUnknown, MExpr, or Array{Equation} (for nesting models).</p>
<h1>Examples</h1>
<p>Models return Arrays of Equations. Here is an example:</p>
<pre><code>function Vanderpol()
    y = Unknown(1.0, "y")
    x = Unknown("x")
    Equation[
        der(x, -1.0) - ((1 - y^2) * x - y)      # == 0 is assumed
        der(y) - x
    ]
end
dump( Vanderpol() )</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L482'>Sims/src/main.jl:482</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='MTime' class='entry-name category-global'>
<div class='category'>[global] &mdash; </div> MTime
</div>
<div class='entry-body'>
<p>The model time - a special unknown variable. </p><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L647'>Sims/src/main.jl:647</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='Model' class='entry-name category-global'>
<div class='category'>[global] &mdash; </div> Model
</div>
<div class='entry-body'>
<p>Represents a vector of Equations. For now, <code>Equation</code> equals <code>Any</code>, but in the future, it may only include ModelType's.</p>
<p>Models return Arrays of Equations. </p>
<h1>Examples</h1>
<pre><code>function Vanderpol()
    y = Unknown(1.0, "y")
    x = Unknown("x")
    Equation[
        der(x, -1.0) - ((1 - y^2) * x - y)      # == 0 is assumed
        der(y) - x
    ]
end
dump( Vanderpol() )
x = sim(Vanderpol(), 50.0)</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/main.jl#L506'>Sims/src/main.jl:506</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='StandardElectricalLibrary' class='entry-name category-global'>
<div class='category'>[global] &mdash; </div> StandardElectricalLibrary
</div>
<div class='entry-body'>
<h1>Analog electrical library</h1>
<p>This library of components is modeled after the Modelica.Electrical.Analog library.</p>
<p>Voltage nodes with type <code>Voltage</code> are the main Unknown type used in electrical circuits. <code>voltage</code> nodes can be single floating point unknowns representing a single voltage node. A <code>Voltage</code> can also be an array representing multiphase circuits or multiple node positions. Lastly, <code>Voltage</code> unknowns can also be complex for use with quasiphasor-type solutions.</p>
<p>The type <code>ElectricalNode</code> is a Union type that can be an Array, a number, an expression, or an Unknown. This is used in model functions to allow passing a <code>Voltage</code> node or a real value (like 0.0 for ground).</p>
<h1>Example</h1>
<pre><code>function ex_ChuaCircuit()
    n1 = Voltage("n1")
    n2 = Voltage("n2")
    n3 = Voltage(4.0, "n3")
    g = 0.0
    function NonlinearResistor(n1::ElectricalNode, n2::ElectricalNode, Ga, Gb, Ve)
        i = Current(compatible_values(n1, n2))
        v = Voltage(compatible_values(n1, n2))
        @equations begin
            Branch(n1, n2, v, i)
            i = ifelse(v < -Ve, Gb .* (v + Ve) - Ga .* Ve,
                       ifelse(v > Ve, Gb .* (v - Ve) + Ga*Ve, Ga*v))
        end
    end
    @equations begin
        Resistor(n1, g, 12.5e-3) 
        Inductor(n1, n2, 18.0)
        Resistor(n2, n3, 1 / 0.565) 
        Capacitor(n2, g, 100.0)
        Capacitor(n3, g, 10.0)
        NonlinearResistor(n3, g, -0.757576, -0.409091, 1.0)
    end
end

y = sim(ex_ChuaCircuit(), 200.0)
wplot(y)</code></pre>
<h1>Components</h1>
<p>Help is available for each of the following components</p>
<ul><li>SeriesProbe </li><li>BranchHeatPort</li><li>Resistor</li><li>Capacitor</li><li>Inductor</li><li>Transformer</li><li>EMF       </li><li>IdealDiode</li><li>IdealThyristor   </li><li>IdealGTOTyristor</li><li>IdealOpAmp     </li><li>ControlledIdealOpeningSwitch </li><li>ControlledIdealClosingSwitch</li><li>ControlledOpenerWithArc    </li><li>ControlledCloserWithArc   </li><li>Diode         </li><li>HeatingDiode  </li><li>SignalVoltage </li><li>SineVoltage   </li><li>StepVoltage   </li><li>SignalCurrent </li></ul><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/electrical.jl#L80'>Sims/src/electrical.jl:80</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class='entry'>
<div id='sim' class='entry-name category-global'>
<div class='category'>[global] &mdash; </div> sim
</div>
<div class='entry-body'>
<p><code>sim</code> is the name of the default solver used to simulate Sims models and also shows the generic simulation API for available solvers (currently <code>dasslsim</code> and <code>sunsim</code>). The default solver is currently <code>dasslsim</code>.</p>
<p><code>sim</code> has many method definitions to accomodate solutions based on intermediate model representations. Also, both positional and keyword arguments are supported (use one or the other after the first argument).</p>
<pre><code>sim(m::Model, tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4)
sim(m::Model; tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4)
sim(m::Sim, tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4)
sim(m::Sim; tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4)
sim(m::SimState, tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4)
sim(m::SimState; tstop::Float64=1.0, Nsteps::Int=500, reltol::Float64=1e-4, abstol::Float64=1e-4)</code></pre>
<h1>Arguments</h1>
<ul><li>`m::Model` : a Model</li><li>`sm::Sim` : a simulation object</li><li>`ss::SimState` : a simulation object</li><li>`tstop::Float64` : the simulation stopping time [secs], default = 1.0</li><li>`Nsteps::Int` : the number of simulation steps, default = 500</li><li>`reltol::Float64` : the relative tolerance, default = 1e-4</li><li>`abstol::Float64` : the absolute tolerance, default = 1e-4</li></ul>
<h1>Returns</h1>
<ul><li>`::SimResult` : the simulation result</li></ul>
<p>A number of optional packages can be used with results, including:</p>
<ul><li>Winston - plotting: `wplot(y::SimResult)`</li><li>Gaston - plotting: `gplot(y::SimResult)` </li><li>DataFrames - conversion to a DataFrame: `convert(DataFrame, y::SimResult)` </li><li>Gadfly - plotting: `plot(y::SimResult, ...)` </li></ul>
<p>For each of these, the package must be installed, and the package pulled in with <code>require</code> or <code>using</code>.</p>
<h1>Details</h1>
<p>The main steps in converting to a model and doing a simulation are:</p>
<pre><code>eqs::EquationSet = elaborate(m::Model)   # flatten the model
sm::Sim = create_sim(eqs::EquationSet)   # prepare for simulation
sm::SimState = create_simstate(sm::Sim)  # prepare for simulation II
y::SimResult = sim(ss::SimState)         # simulate</code></pre>
<p>The following are equivalent:</p>
<pre><code>y = sim(create_simstate(create(sim(elaborate(m)))))
y = sim(m)</code></pre>
<h1>Example</h1>
<pre><code>using Sims
function Vanderpol()
    y = Unknown(1.0, "y")   # The 1.0 is the initial value. "y" is for plotting.
    x = Unknown("x")        # The initial value is zero if not given.
    # The following gives the return value which is a list of equations.
    # Expressions with Unknowns are kept as expressions. Expressions of
    # regular variables are evaluated immediately (like normal).
    @equations begin
        # The -1.0 in der(x, -1.0) is the initial value for the derivative 
        der(x, -1.0) = (1 - y^2) * x - y 
        der(y) = x
    end
end

v = Vanderpol()       # returns the hierarchical model
y = sunsim(v, 50.0)
using Winston
wplot(y)</code></pre><div class='entry-meta'>
<strong>Details:</strong>
<table class='meta-table'>
<tr >
<td><strong>source:</strong></td><td >
<a href='https://github.com/tshort/Sims.jl/tree/92c3f971e741dd0a8b0d026caa14c9c9c1adf332/src/Sims.jl#L168'>Sims/src/Sims.jl:168</a></td>
</tr>
</table>
</div>
</div>
</div>
</div>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.5.0/codemirror.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.5.0/mode/julia/julia.min.js"></script>



<script type="text/javascript" src="static/custom.js"></script>

